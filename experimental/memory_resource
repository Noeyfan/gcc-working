namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
namespace pmr {
  class memory_resource
  {
    static constexpr size_t __max_align = alignof(max_align_t);
  public:
    virtual ~memory_resource();

    void* allocate(size_t __bytes,
		   size_t __alignment = max_align)
    { return do_allocate(__bytes, __alignment); }

    void deallocate(void* __p, size_t __bytes,
		    size_t __alignment = __max_align)
    { return do_deallocate(__p, __bytes, __alignment); }

    bool is_equal(const memory_resource& __other) const noexcept
    { return do_is_equal(__other);}

  protected:
    virtual void* do_allocate(size_t __bytes, size_t __alignment) = 0;
    virtual void do_deallocate(void* __p, size_t __bytes,
			       size_t __alignment) = 0;
    virtual bool do_is_equal(const memory_resource& __other) const noexcept = 0;
  };

  bool operator==(const memory_resource& __a,
		  const memory_resource& __b) noexcept
  { return &__a == &__b || __a.is_equal(__b); }

  bool operator!=(const memory_resource& __a,
		  const memory_resource& __b) noexcept
  { return !(__a == __b); }

  template <typename _Tp>
    class polymorphic_allocator
    {
      memory_resource* m_resource;

    public:
      using value_type = _Tp;
    };
}
}
}
}
